if (keyimagin > 0) {
haveimaginary <- T
if (minimgain <= 0 && keyx1 > 0) {
changepi <- T
n_trm <- n_obs * get_pi(odds_ratio, std_err, n_obs, n_trm)
n_cnt <- n_obs - n_trm
} else
{stop("Cannot generate a usable contingency table! Please consider using Pearson's chi-squared approach (under development).")}
}
# a1, b1, c1, d1 are one solution for the 4 cells in the contingency table
a1 <- get_a1_kfnl(odds_ratio, std_err, n_obs, n_trm)
b1 <- n_cnt - a1
c1 <- get_c1_kfnl(odds_ratio, std_err, n_obs, n_trm)
d1 <- n_trm - c1
# a2, b2, c2, d2 are the second solution for the 4 cells in the contingency table
a2 <- get_a2_kfnl(odds_ratio, std_err, n_obs, n_trm)
b2 <- n_cnt - a2
c2 <- get_c2_kfnl(odds_ratio, std_err, n_obs, n_trm)
d2 <- n_trm - c2
# Differences between these two sets of solutions:
### a1 c1 are small while a2 c2 are large
### b1 d1 are large while b2 d2 are small
### the goal is to get fewest swithes to invalidate the inference
### remove the solution if one cell has fewerer than 5 cases or negative cells or nan cells
check1 <- check2 <- TRUE
if (!(n_cnt>=a1 && a1>=5 && n_cnt>=b1 && b1>=5 && n_trm>=c1 && c1>=5 && n_trm>=d1 && d1>=5)
|| is.nan(a1) || is.nan(b1) || is.nan(c1) || is.nan(d1))
{check1 <- FALSE}
if (!(n_cnt>=a2 && a2>=5 && n_cnt>=b2 && b2>=5 && n_trm>=c2 && c2>=5 && n_trm>=d2 && d2>=5)
|| is.nan(a2) || is.nan(b2) || is.nan(c2) || is.nan(d2))
{check2 <- FALSE}
if (check1) {
table_bstart1 <- get_abcd_kfnl(a1, b1, c1, d1)
solution1 <- getswitch(table_bstart1, thr_t, switch_trm, n_obs)
}
if (check2) {
table_bstart2 <- get_abcd_kfnl(a2, b2, c2, d2)
solution2 <- getswitch(table_bstart2, thr_t, switch_trm, n_obs)
}
if (!check1 && !check2)
{stop("Cannot generate a usable contingency table!")}
# get the number of switches for solutions that satisfy the requirements
if (check1 && check2) {
final_switch1 <- solution1$final_switch
final_switch2 <- solution2$final_switch
if (final_switch1 < final_switch2) {
final_solution <- getswitch(table_bstart1, thr_t, switch_trm, n_obs)
} else {
final_solution <- getswitch(table_bstart2, thr_t, switch_trm, n_obs)
}
}
if (check1 && !check2) {
final_solution <- getswitch(table_bstart1, thr_t, switch_trm, n_obs)
}
if (!check1 && check2) {
final_solution <- getswitch(table_bstart2, thr_t, switch_trm, n_obs)
}
if (switch_trm && dcroddsratio_ob)
{transferway <- "treatment success to treatment failure,"}
if (switch_trm && !dcroddsratio_ob)
{transferway <- "treatment failure to treatment success,"}
if (!switch_trm && dcroddsratio_ob)
{transferway <- "control failure to control success,"}
if (!switch_trm && !dcroddsratio_ob)
{transferway <- "control success to control failure,"}
if (final_solution$needtworows) {
if (switch_trm && dcroddsratio_ob)
{transferway_extra <- "control failure to control success,"}
if (switch_trm && !dcroddsratio_ob)
{transferway_extra <- "control success to control failure,"}
if (!switch_trm && dcroddsratio_ob)
{transferway_extra <- "treatment success to treatment failure,"}
if (!switch_trm && !dcroddsratio_ob)
{transferway_extra <- "treatment failure to treatment success,"}
}
if (invalidate_ob) {
change <- "To invalidate the inference,"
} else {
if est_eff >= 0
{change <- "To sustain an inference for a positive treatment effect,"} else
{change <- "To sustain an inference for a negative treatment effect,"}
}
if (!final_solution$needtworows) {
conclusion1 <- paste(change, sprintf("%d cases need to be transferred from", final_solution$final_switch),
transferway, c("as shown from the Implied Table to the Transfer Table."))
} else {
conclusion1 <- paste(change, c("only transferring cases from"), transferway,
sprintf("is not enough. We also need to transfer %d cases from", final_solution$final_extra),
transferway_extra, c("as shown from the Implied Table to the Transfer Table."))
}
conclusion2 <- sprintf("For the Implied Table, we have estimate of %.3f, with standard error of %.3f and t-ratio of %.3f.",
final_solution$est_eff_start, final_solution$std_err_start, final_solution$t_start)
conclusion3 <- sprintf("For the Transfer Table, we have estimate of %.3f, with standard error of %.3f and t-ratio of %.3f.",
final_solution$est_eff_final, final_solution$std_err_final, final_solution$t_final)
notice <- c("(Values have been rounded to the nearest integer.
This may cause a little change to the estimated effect for the Implied Table.)")
if (haveimaginary && changepi)
{conclusion1 <- paste(sprintf("In order to generate a usable implied contingency table, we change the number of treatment cases to %d
(originally this number is %d.",
final_solution$table_start[2,1]+final_solution$table_start[2,2], user_ntrm),
conclusion1)}
result <- list(conclusion1, Implied_Table = final_solution$table_start, notice, Transfer_Table = final_solution$table_final,
conclusion2, conclusion3, Implied_Estimate = final_solution$est_eff_start, Transfer_Estimate = final_solution$est_eff_final,
Implied_SE = final_solution$std_err_start, Transfer_SE = final_solution$std_err_final,
Implied_tratio = final_solution$t_start, Transfer_tratio = final_solution$t_final,
Taylor_predict = final_solution$taylor_pred, Percent_bias_predict = final_solution$perc_bias_pred)
result
est_eff = -0.0183
std_err =  0.62076
n_obs =  42
n_covariates = 3
n_trm = 30
switch_trm = T
alpha = 0.05
tails = 2
to_return = "print"
if (est_eff < 0) {
thr_t <- stats::qt(1 - (alpha / tails), n_obs - n_covariates - 1) * -1
} else {
thr_t <- stats::qt(1 - (alpha / tails), n_obs - n_covariates - 1)
}
# stop message
if (n_obs <= 0 || n_trm <= 0)
{stop("Please enter positive integers for sample size and number of treatment group cases!")}
if (n_obs <= n_trm)
{stop("The total sample size should be larger than the number of treatment group cases.")}
odds_ratio <- exp(est_eff)
# n_trm is the number of observations in the treatment group (c+d)
# n_cnt is the number of observations in the control group (a+b)
n_cnt <- n_obs - n_trm
# t_ob is the t value calculated based on observed estimate and standard error
t_ob <- est_eff/std_err
# invalidate_ob is true - the observed result is significant - we are invalidating the observed result
invalidate_ob <- isinvalidate(thr_t,t_ob)
# dcroddsratio_ob is true - our goal is to decrease the odds ratio
dcroddsratio_ob <- isdcroddsratio(thr_t, t_ob)
# to record the original treatment cases in case we need to adjust it
user_ntrm <- n_trm
# check if the implied table solution may contain imaginary numbers
haveimaginary <- F
changepi <- F
# set the default value for whether we need and can adjust pi (ratio of treatment cases)
# to remove the imaginary part
keyimagin <- (4 + 4 * odds_ratio^2 + odds_ratio *
(-8 + 4 * n_obs * std_err^2 - n_obs * n_trm * std_err^4 + n_trm^2 * std_err^4))
minimgain <- 4 + 4 * odds_ratio^2 + odds_ratio * (-8 + n_obs * std_err^2 * (4 - 0.25 * n_obs * std_err^2))
keyx1 <- 4 + 4 * odds_ratio^2 + odds_ratio * (-8 + 4 * n_obs * std_err^2)
if (keyimagin > 0) {
haveimaginary <- T
if (minimgain <= 0 && keyx1 > 0) {
changepi <- T
n_trm <- n_obs * get_pi(odds_ratio, std_err, n_obs, n_trm)
n_cnt <- n_obs - n_trm
} else
{stop("Cannot generate a usable contingency table! Please consider using Pearson's chi-squared approach (under development).")}
}
# a1, b1, c1, d1 are one solution for the 4 cells in the contingency table
a1 <- get_a1_kfnl(odds_ratio, std_err, n_obs, n_trm)
b1 <- n_cnt - a1
c1 <- get_c1_kfnl(odds_ratio, std_err, n_obs, n_trm)
d1 <- n_trm - c1
# a2, b2, c2, d2 are the second solution for the 4 cells in the contingency table
a2 <- get_a2_kfnl(odds_ratio, std_err, n_obs, n_trm)
b2 <- n_cnt - a2
c2 <- get_c2_kfnl(odds_ratio, std_err, n_obs, n_trm)
d2 <- n_trm - c2
# Differences between these two sets of solutions:
### a1 c1 are small while a2 c2 are large
### b1 d1 are large while b2 d2 are small
### the goal is to get fewest swithes to invalidate the inference
### remove the solution if one cell has fewerer than 5 cases or negative cells or nan cells
check1 <- check2 <- TRUE
if (!(n_cnt>=a1 && a1>=5 && n_cnt>=b1 && b1>=5 && n_trm>=c1 && c1>=5 && n_trm>=d1 && d1>=5)
|| is.nan(a1) || is.nan(b1) || is.nan(c1) || is.nan(d1))
{check1 <- FALSE}
if (!(n_cnt>=a2 && a2>=5 && n_cnt>=b2 && b2>=5 && n_trm>=c2 && c2>=5 && n_trm>=d2 && d2>=5)
|| is.nan(a2) || is.nan(b2) || is.nan(c2) || is.nan(d2))
{check2 <- FALSE}
if (check1) {
table_bstart1 <- get_abcd_kfnl(a1, b1, c1, d1)
solution1 <- getswitch(table_bstart1, thr_t, switch_trm, n_obs)
}
if (check2) {
table_bstart2 <- get_abcd_kfnl(a2, b2, c2, d2)
solution2 <- getswitch(table_bstart2, thr_t, switch_trm, n_obs)
}
if (!check1 && !check2)
{stop("Cannot generate a usable contingency table!")}
# get the number of switches for solutions that satisfy the requirements
if (check1 && check2) {
final_switch1 <- solution1$final_switch
final_switch2 <- solution2$final_switch
if (final_switch1 < final_switch2) {
final_solution <- getswitch(table_bstart1, thr_t, switch_trm, n_obs)
} else {
final_solution <- getswitch(table_bstart2, thr_t, switch_trm, n_obs)
}
}
if (check1 && !check2) {
final_solution <- getswitch(table_bstart1, thr_t, switch_trm, n_obs)
}
if (!check1 && check2) {
final_solution <- getswitch(table_bstart2, thr_t, switch_trm, n_obs)
}
if (switch_trm && dcroddsratio_ob)
{transferway <- "treatment success to treatment failure,"}
if (switch_trm && !dcroddsratio_ob)
{transferway <- "treatment failure to treatment success,"}
if (!switch_trm && dcroddsratio_ob)
{transferway <- "control failure to control success,"}
if (!switch_trm && !dcroddsratio_ob)
{transferway <- "control success to control failure,"}
if (final_solution$needtworows) {
if (switch_trm && dcroddsratio_ob)
{transferway_extra <- "control failure to control success,"}
if (switch_trm && !dcroddsratio_ob)
{transferway_extra <- "control success to control failure,"}
if (!switch_trm && dcroddsratio_ob)
{transferway_extra <- "treatment success to treatment failure,"}
if (!switch_trm && !dcroddsratio_ob)
{transferway_extra <- "treatment failure to treatment success,"}
}
if (invalidate_ob) {
change <- "To invalidate the inference,"
} else {
if est_eff >= 0
{change <- "To sustain an inference for a positive treatment effect,"} else
{change <- "To sustain an inference for a negative treatment effect,"}
}
if (!final_solution$needtworows) {
conclusion1 <- paste(change, sprintf("%d cases need to be transferred from", final_solution$final_switch),
transferway, c("as shown from the Implied Table to the Transfer Table."))
} else {
conclusion1 <- paste(change, c("only transferring cases from"), transferway,
sprintf("is not enough. We also need to transfer %d cases from", final_solution$final_extra),
transferway_extra, c("as shown from the Implied Table to the Transfer Table."))
}
conclusion2 <- sprintf("For the Implied Table, we have estimate of %.3f, with standard error of %.3f and t-ratio of %.3f.",
final_solution$est_eff_start, final_solution$std_err_start, final_solution$t_start)
conclusion3 <- sprintf("For the Transfer Table, we have estimate of %.3f, with standard error of %.3f and t-ratio of %.3f.",
final_solution$est_eff_final, final_solution$std_err_final, final_solution$t_final)
notice <- c("(Values have been rounded to the nearest integer. This may cause a little change to the estimated effect for the Implied Table.)")
if (haveimaginary && changepi)
{conclusion1 <- paste(sprintf("In order to generate a usable implied contingency table, we change the number of treatment cases to %d (originally this number is %d).",
final_solution$table_start[2,1]+final_solution$table_start[2,2], user_ntrm), conclusion1)}
result <- list(conclusion1, Implied_Table = final_solution$table_start, notice, Transfer_Table = final_solution$table_final,
conclusion2, conclusion3, Implied_Estimate = final_solution$est_eff_start, Transfer_Estimate = final_solution$est_eff_final,
Implied_SE = final_solution$std_err_start, Transfer_SE = final_solution$std_err_final,
Implied_tratio = final_solution$t_start, Transfer_tratio = final_solution$t_final,
Taylor_predict = final_solution$taylor_pred, Percent_bias_predict = final_solution$perc_bias_pred)
result
devtools::install_github("jrosen48/konfound")
library(konfound)
pkonfound(2.5, 0.5, 20888, 3, n_trm = 17888, switch_trm=TRUE, non_linear = TRUE)$Implied_SE
pkonfound(2.5, 0.5, 20888, 3, n_trm = 17888, switch_trm=TRUE, non_linear = TRUE)
pkonfound(-0.0183, 0.62076, 42, 3, n_trm = 30, switch_trm=TRUE, non_linear = TRUE)
install.packages("devtools")
devtools::install_github("jrosen48/konfound")
install.packages("devtools")
library(konfound)
pkonfound(2.5, 0.5, 20888, 3, n_trm = 17888, switch_trm=TRUE, non_linear = TRUE)$Implied_SE
pkonfound(2.5, 0.5, 20888, 3, n_trm = 17888, switch_trm=TRUE, non_linear = TRUE)
pkonfound(-0.0183, 0.62076, 42, 3, n_trm = 30, switch_trm=TRUE, non_linear = TRUE)
pkonfound(-0.0183, 0.62076, 42, 3, n_trm = 30, switch_trm=TRUE, non_linear = TRUE)$Implied_SE
pkonfound(0.003, 0.003, 40000, 3, n_trm = 20000, switch_trm=TRUE, non_linear = TRUE)
setwd("C:/Users/user/Dropbox (Personal)/Sensitivity analysis of Mediation/R package/conmediator")
library(ggplot2)
devtools::check()
devtools::install()
library(conmediator)
rxmu_plot(rxmo=0.0995,rxy=0.0995,rymo=0.1,rmomu=0.1,rymu=0.1, nobs=100, labelest = "indirect1",conflevel=0.95)
p1 <- rxmu_plot(rxmo=0.0995,rxy=0.0995,rymo=0.1,rmomu=0.1,rymu=0.1, nobs=100, labelest = "indirect1",conflevel=0.95)
p1 <- p1 + labs(y="low")
p1
library(conmediator)
setwd("C:/Users/user/Dropbox (Personal)/Sensitivity analysis of Mediation/R package/conmediator")
library(ggplot2)
devtools::check()
devtools::install()
library(conmediator)
rmomu_plot(rxmo=0.3713,rxy=0.0995,rymo=0.1,rxmu=0.0995,rymu=0.1, nobs=100, labelest = "c",conflevel=0.95)
library(conmediator)
rmomu_plot(rxmo=0.3713,rxy=0.0995,rymo=0.1,rxmu=0.0995,rymu=0.1, nobs=100, labelest = "c",conflevel=0.95)
rmomu_plot(rxmo=0.3713,rxy=0.3713,rymo=0.5,rxmu=0.3713,rymu=0.5, nobs=100, labelest = "c",conflevel=0.95)
result <- rxmu_data(rxmo=0.0995,rxy=0.0995,rymo=0.1,rmomu=0.5,rymu=0.5, nobs=100, labelest = "indirect1",conflevel=0.95)
result <- rxmu_data(rxmo=0.0995,rxy=0.0995,rymo=0.1,rmomu=0.5,rymu=0.5, nobs=100,conflevel=0.95)
head(result)
rymu_plot(rxmo=0.3713,rxy=0.3713,rymo=0.5,rxmu=0.3713,rmomu=0.5, nobs=100, labelest = "a1",conflevel=0.95)
rymu_plot(rxmo=0.3713,rxy=0.3713,rymo=0.5,rxmu=0.3713,rmomu=0.5, nobs=100, labelest = "b1",conflevel=0.95)
result <- rymu_plot(rxmo=0.3713,rxy=0.3713,rymo=0.5,rxmu=0.3713,rmomu=0.5, nobs=100,conflevel=0.95)
head(result)
result <- rymu_data(rxmo=0.3713,rxy=0.3713,rymo=0.5,rxmu=0.3713,rmomu=0.5, nobs=100,conflevel=0.95)
head(result)
devtools::install_github("jtbates/kliqfindr")
library(kliqfindr)
getwd()
setwd("C:/Users/user/Dropbox (Personal)/R/Kliqfindr")
getwd()
stanne.list <- read.csv("stanne.list", header = F)
stanne.list
rm(list = ls())
library(kliqfindr)
stanne.list
system.file('extdata', 'stanne.list', package='kliqfindr')
test.list <- read.csv("stanne.list", header = F)
test <- winkliq_run('test.list')
test <- winkliq_run(test.list)
test <- winkliq_run('test.list')
test <- winkliq_run(test.list)
test.list
test <- winkliq_run('teststanne.list')
test
head(teststanne$place)
teststanne <- winkliq_run('teststanne.list')
teststanne
teststanne$place
head(teststanne$place)
install.packages("igraph")
library(igraph)
teststanne$place
test <- winkliq_run('ati19x.list')
test
head(test$place)
test <- winkliq_run('ati19x.list')
test <- winkliq_run('ati19x.list')
head(test$place)
nodes <- read.csv("ati19x_tie.csv", header=T, as.is=T)
head(nodes)
ties <- read.csv("ati19x_tie.csv", header=T, as.is=T)
test
links <- read.csv("ati19x_node.csv", header=T, as.is=T)
head(nodes)
head(links)
head(ties)
head(links)
ties <- read.csv("ati19x_tie.csv", header=T, as.is=T)
nodes <- read.csv("ati19x_node.csv", header=T, as.is=T)
nrow(ties); nrow(unique(links[,c("sender","receiver")]))
nrow(nodes); length(unique(nodes$node))
nrow(ties); nrow(unique(ties[,c("sender","receiver")]))
network <- graph_from_data_frame(d=ties, vertices=nodes, directed=F)
plot(network,vertex.label=NA,vertex.size=4)
plot(network,vertex.label=node,vertex.size=4)
plot(network,vertex.label=nodes$node,vertex.size=4)
plot(network,vertex.label=nodes$node,vertex.size=7)
plot(network,vertex.label=nodes$node,vertex.size=9)
cd_modu <- cluster_fast_greedy(as.undirected(net))
cluster_fast_greedy(as.undirected(network))$membership
network <- graph_from_data_frame(d=ties, vertices=nodes, directed=T)
plot(net, edge.arrow.size=.2,vertex.label=nodes$node,vertex.size=4)
plot(network, edge.arrow.size=.2,vertex.label=nodes$node,vertex.size=4)
plot(network, edge.arrow.size=.2,vertex.label=nodes$node,vertex.size=9)
cluster_fast_greedy(as.undirected(network))$membership
cluster_fast_greedy(as.undirected(network))
V(network)
plot(net, edge.arrow.size=.2, vertex.color=V(network)$community, vertex.label=NA,vertex.size=4)
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community, vertex.label=NA,vertex.size=4)
test$place
test$place[,c("actor","subgroup")]
network
V(network)
V(network)$community <- test$place[order(node),]$subgroup
clusterbykf <- test$place
clusterbykf
V(network)$community <- test$place[order(actor),]$subgroup
groupbykf <- test$place
groupbykf <- groupbykf[order(actor),]
groupbykf <- groupbykf[order(groupbykf$actor),]
groupbykf
V(network)$community <- groupbykf$subgroup
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community, vertex.label=NA,vertex.size=4)
plot(net, edge.arrow.size=.2, vertex.color=V(net)$community, vertex.label=NA,vertex.size=4,layout=l)
plot(net, edge.arrow.size=.2, vertex.color=V(net)$community, vertex.label=NA,vertex.size=4,layout=layout_with_fr)
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community, vertex.label=NA,vertex.size=4,layout=layout_with_fr)
l <- layout_with_fr(network, weights = 3)
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community, vertex.label=NA,vertex.size=4,layout=l)
V(network)
V(network)$attr1
vertex_attr(network)
l <- layout_with_fr(network, weights = 3)
l <- layout_with_fr(network, weights = 0.5)
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community,
vertex.label=V(network)$name,vertex.size=4,layout=layout_with_fr)
V(network)$community
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community,
vertex.label=V(network)$name,vertex.size=7,layout=layout_with_fr)
test <- winkliq_run('ati19x.list')
test
library(kliqfindr)
head(test$place)
groupbykf <- test$place[,c(actor, subgroup)]
groupbykf <- test$place[,c("actor", "subgroup")]
groupbykf
library(igraph)
ties <- read.csv("ati19x_tie.csv", header=T, as.is=T)
nodes <- read.csv("ati19x_node.csv", header=T, as.is=T)
head(ties)
head(nodes)
nrow(ties); nrow(unique(ties[,c("sender","receiver")]))
nrow(nodes); length(unique(nodes$node))
network <- graph_from_data_frame(d=ties, vertices=nodes, directed=T)
plot(network, edge.arrow.size=.2,vertex.label=V(network)$name,vertex.size=9)
plot(network, edge.arrow.size=.2,vertex.label=V(network)$name,vertex.size=9,layout=layout_with_fr)
groupbykf <- groupbykf[order(groupbykf$actor),]
V(network)$community <- groupbykf$subgroup
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community,
vertex.label=V(network)$name,vertex.size=7,layout=layout_with_fr)
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community,
vertex.label=V(network)$name,vertex.size=7,layout=layout_with_fr)
help(read.csv)
help(read.csv)
install.packages('devtools')
devtools::install_github("jtbates/kliqfindr")
install.packages("igraph")
library(igraph)
g1 <- graph(edges=c(1,2,2,3,3,1), n=3, directed=F)
plot(g1)
g4 <- graph( c("John", "Jim", "Jim", "Jack", "Jim", "John", "John", "Joe"),
isolates=c("Jesse", "Janis", "Jennifer", "Justin") )
plot(g4, edge.arrow.size=.5, vertex.color="gold", vertex.size=15,
vertex.frame.color="gray", vertex.label.color="black",
vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.2)
E(g4)
V(g4)
g4[]
V(g4)$name
V(g4)$gender <- c("male", "male", "male", "male", "female", "female", "male", "male")
E(g4)$type <- "email" # Edge attribute, assign "email" to all edges
E(g4)$weight <- 10    # Edge weight, setting all existing edges to 10
edge_attr(g4)
vertex_attr(g4)
library(kliqfindr)
rm(list = ls())
getwd()
setwd("C:/Users/user/Dropbox (Personal)/R/Kliqfindr")
getwd()
test <- winkliq_run('ati19x.list')
test
head(test$place)
groupbykf <- test$place[,c("actor", "subgroup")]
groupbykf
library(igraph)
ties <- read.csv("ati19x_tie.csv", header=T, as.is=T)
nodes <- read.csv("ati19x_node.csv", header=T, as.is=T)
head(ties)
nrow(ties); nrow(unique(ties[,c("sender","receiver")]))
nrow(nodes); length(unique(nodes$node))
network <- graph_from_data_frame(d=ties, vertices=nodes, directed=T)
plot(network, edge.arrow.size=.2,vertex.label=V(network)$name,vertex.size=9,layout=layout_with_fr)
groupbykf <- groupbykf[order(groupbykf$actor),]
V(network)$community <- groupbykf$subgroup
V(network)$community
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community,
vertex.label=V(network)$name,vertex.size=7,layout=layout_with_fr)
plot(network, edge.arrow.size=.2, vertex.color=V(network)$community,
vertex.label=V(network)$name,vertex.size=7,layout=layout_with_fr)
library(conmediator)
library(conmediator)
rxmu_plot(rxmo=0.0995,rxy=0.0995,rymo=0.1,rmomu=0.5,rymu=0.5, nobs=100, labelest = "indirect1",conflevel=0.95)
rmomu_plot(rxmo=0.3713,rxy=0.3713,rymo=0.5,rxmu=0.3713,rymu=0.5, nobs=100, labelest = "c",conflevel=0.95)
rxmu_plot(rxmo=0.0995,rxy=0.0995,rymo=0.1,rmomu=0.5,rymu=0.5, nobs=100, labelest = "indirect1",conflevel=0.95)
rm(list = ls())
setwd("C:/Users/user/Dropbox (Personal)/R/Kliqfindr")
library(kliqfindr)
test <- winkliq_run('ati19x.list')
groupbykf <- test$place[,c("actor", "subgroup")]
library(igraph)
ties <- read.csv("ati19x_tie.csv", header=T, as.is=T)
nodes <- read.csv("ati19x_node.csv", header=T, as.is=T)
network <- graph_from_data_frame(d=ties, vertices=nodes, directed=T)
weight.community=function(row,membership,weigth.within,weight.between){
if(as.numeric(membership[which(names(membership)==row[1])])==as.numeric(membership[which(names(membership)==row[2])])){
weight=weigth.within
}else{
weight=weight.between
}
return(weight)
}
nclus <- member %>% select(Membership) %>% distinct() %>% nrow
nclus <- groupbykf %>% select(Membership) %>% distinct() %>% nrow
install.packages('RColorBrewer')
library(RColorBrewer)
library(igraphdata)
library(tidyverse)
install.packages("igraphdata")
library(igraphdata)
library(tidyverse)
library(igraph)
library(RColorBrewer)
nclus <- groupbykf %>% select(Membership) %>% distinct() %>% nrow
head(groupbykf)
nclus <- groupbykf %>% select(subgroup) %>% distinct() %>% nrow
nclus
net$palette <- brewer.pal(nclus, "Set3")
network$palette <- brewer.pal(nclus, "Set3")
network$paletter
network$palette
help(brewer.pal)
plot(network, edge.arrow.size=.4,vertex.label=NA, vertex.color=network$Membership)
groupbykf <- groupbykf[order(groupbykf$actor),]
V(network)$community <- groupbykf$subgroup
plot(network, edge.arrow.size=.4,vertex.color=V(network)$community,vertex.label=V(network)$name,vertex.size=7,layout=layout_with_fr)
get.edgelist(network)
membership <- groupbykf$subgroup
names(membership) <- as.character(groupbykf$actor)
E(network)$weight=apply(get.edgelist(network),1,weight.community,membership,10,1)
E(network)$weight=apply(get.edgelist(network),1,weight.community,membership,80,1)
network$layout=layout.fruchterman.reingold(network,weights=E(network)$weight)
set.seed(1)
plot(network, edge.arrow.size=.4,vertex.label=NA, vertex.color=member$Membership)
plot(network, edge.arrow.size=.4,vertex.label=NA, vertex.color=V(network)$community)
plot(network, edge.arrow.size=.4,vertex.label=V(network)$name, vertex.color=V(network)$community)
